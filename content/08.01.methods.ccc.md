## Methods

The code needed to reproduce our analyses and generate the figures is available in [https://github.com/greenelab/ccc](https://github.com/greenelab/ccc).
We provide scripts to download the data and run all the steps.
A Docker image is also available to use the same runtime environment.


### The CCC algorithm {#sec:ccc_algo .page_break_before}

The Clustermatch Correlation Coefficient (CCC) computes a similarity value $c \in \left[0,1\right]$ between any pair of numerical or categorical features/variables $\mathbf{x}$ and $\mathbf{y}$ measured on $n$ objects.
CCC assumes that if two features $\mathbf{x}$ and $\mathbf{y}$ are similar, the partitioning of the $n$ objects by clustering them using each feature separately should match.
For example, given $\mathbf{x}=(11, 27, 32, 40)$ and $\mathbf{y}=10x=(110, 270, 320, 400)$, with $n=4$, partitioning each variable into two clusters ($k=2$) using their medians (29.5 for $\mathbf{x}$ and 295 for $\mathbf{y}$) results in partitions $\Omega^{\mathbf{x}}_{k=2}=(1, 1, 2, 2)$ for $\mathbf{x}$, and $\Omega^{\mathbf{y}}_{k=2}=(1, 1, 2, 2)$ for $\mathbf{y}$.
To measure the agreement between these partitions, any measure of similarity between partitions can be used, such as the adjusted Rand index (ARI) [@doi:10.1007/BF01908075], which would return the maximum value (1.0).
The optimal number of clusters to find a relationship between any two features may not always be the same.
For instance, in the quadratic example in Figure @fig:datasets_rel, CCC returns a value of 0.36 (grouping objects in four clusters using one feature and two using the other).
If two clusters were used instead, CCC would return a similarity value of 0.02.
To address this, the CCC algorithm (shown below) searches for the optimal number of clusters given a maximum $k$, which is its single parameter $k_{\mathrm{max}}$.

![
](images/intro/ccc_algorithm/ccc_algorithm.svg "CCC algorithm"){width="75%"}

The algorithm `ccc` generates a list of partitionings for each feature $\mathbf{x}$ and $\mathbf{y}$ (lines 14 and 15).
It then computes the Adjusted Rand Index (ARI) between each partition in $\Omega^{\mathbf{x}}$ and $\Omega^{\mathbf{y}}$ (line 16), and retains the pair that generates the highest ARI.
Since ARI does not provide a lower bound (it could return negative values, which are not meaningful in our case), CCC returns only values between 0 and 1 (line 17).


CCC only requires two partitions of objects in order to compute a similarity value.
This means that any type of feature that can be used to group objects can be supported.
For numerical features (lines 2 to 5 in the `get_partitions` function), quantiles are used to form clusters.
For example, the median generates two clusters of objects, ranging from $k=2$ to $k=k_{\mathrm{max}}$.
For categorical features (lines 7 to 9), the categories are used to form clusters.
This allows numerical and categorical variables to be integrated since clusters do not need to be ordered.


For our analyses, we used a maximum $k_{\mathrm{max}}$ of 10.
This resulted in 18 partitions being generated for each gene pair (9 for each gene, from $k=2$ to $k=10$), and 81 ARI comparisons being performed.
Lowering the value of $k_{\mathrm{max}}$ can reduce computation time, although at the cost of missing more complex/general relationships.
Our examples in Figure @fig:datasets_rel suggest that using $k_{\mathrm{max}}=2$ would only allow CCC to find linear-only patterns, which could be a valid use case scenario if only this kind of relationships are desired.
In this case, only two partitions would be generated, and only one ARI comparison would be performed.
Our Python implementation of CCC provides flexibility in specifying $k_{\mathrm{max}}$, as it can be set to a custom list of integers.
For example, `[2, 5, 10]` would partition the data into two, five and ten clusters.


For our study, we used three CPU cores to generate partitions and compute the similarity of a single pair of features (genes).
This helped speed up the computation of the correlation coefficient.
In the future, graphical processing units (GPU) could be used to further parallelize the computation of CCC.


We provide a Python implementation of CCC, optimized with the `numba` package [@doi:10.1145/2833157.2833162], in our Github repository [@url:https://github.com/greenelab/clustermatch-gene-expr].
Additionally, a package is published in the Python Package Index (PyPI) for easy installation.
